# Docs for the GitHub Actions SFTP Deploy action: https://github.com/marketplace/actions/ftp-sftp-file-deployer

name: Build and Deploy Umbraco App to Fasthosts

on:
  push:
    branches:
      - main
    # The 'paths' keyword now ensures this workflow only runs when files
    # under the 'src' folder are modified.
    paths:
      - 'src/**'
  # The new 'workflow_dispatch' event allows you to run this workflow manually
  # and provide custom inputs.
  workflow_dispatch:
    inputs:
      dry-run:
        description: "Perform a dry run without actually deploying files."
        type: boolean
        required: true
        default: false      

jobs:
  build:
    runs-on: windows-latest
    permissions:
      contents: read

    steps:
      - uses: actions/checkout@v4

      - name: Set up .NET Core
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '8.x'

      - name: Build with dotnet
        run: dotnet build --configuration Release

      - name: dotnet publish
        run: dotnet publish -c Release -o "publish" --no-self-contained

      - name: Upload artifact for deployment job
        uses: actions/upload-artifact@v4
        with:
          name: .net-app
          path: publish

  deploy:
    runs-on: ubuntu-latest
    needs: build
    permissions:
      id-token: write
      contents: read

    steps:
      - uses: actions/checkout@v4

      - name: Download artifact from build job
        uses: actions/download-artifact@v4
        with:
          name: .net-app
          path: ./app_publish
      
      - name: Create appsettings.json for Production
        env:
          UMBRACO_DB_DSN: ${{ secrets.UMBRACO_DB_DSN }}
          SMTP_USERNAME: ${{ secrets.SMTP_USERNAME }}
          SMTP_PASSWORD: ${{ secrets.SMTP_PASSWORD }}
          GOOGLE_CLIENTID: ${{ secrets.GOOGLE_CLIENTID }}
          GOOGLE_CLIENTSECRET: ${{ secrets.GOOGLE_CLIENTSECRET }}
          RECAPCHA_SITEKEY: ${{ secrets.RECAPTCHA_SITEKEY }}
          RECAPCHA_SECRETKEY: ${{ secrets.RECAPTCHA_SECRETKEY }}
        run: |
          # Use 'jq' to modify the JSON file.
          # The DSN and SMTP credentials are now passed via environment variables.
          jq \
            --arg dsn "$UMBRACO_DB_DSN" \
            --arg smtpUsername "$SMTP_USERNAME" \
            --arg smtpPassword "$SMTP_PASSWORD" \
            --arg googleClientID "$GOOGLE_CLIENTID" \
            --arg googleClientSecret "$GOOGLE_CLIENTSECRET" \
            --arg recaptchaSiteKey "$RECAPCHA_SITEKEY" \
            --arg recaptchaSecretKey "$RECAPCHA_SECRETKEY" \
            '.ConnectionStrings = {
                "umbracoDbDSN": $dsn,
                "umbracoDbDSN_ProviderName": "Microsoft.Data.SqlClient"
            } |
            .uSync.Settings.ImportAtStartup = true |
            .Umbraco.CMS.Global.Smtp = {
                "Host": "smtp.livemail.co.uk",
                "Port": 25,
                "Username": $smtpUsername,
                "Password": $smtpPassword,
                "EnableSsl": true,
                "From": "support@theexchange-tod.com"
            } |
            .Authentication.Google = {
                "ClientId": $googleClientID,
                "ClientSecret": $googleClientSecret
            } |
            .Recaptcha = {
                "SiteKey": $recaptchaSiteKey,
                "SecretKey": $recaptchaSecretKey
            }' \
            app_publish/appsettings.json > app_publish/appsettings.json.tmp && \
            mv app_publish/appsettings.json.tmp app_publish/appsettings.json
            
      # Upload to Fasthosts
      - name: "Install dependencies"
        shell: bash
        run: |
          echo "::group::Install packages"
          DEBIAN_FRONTEND=noninteractive sudo apt-get update && sudo apt-get install --no-install-recommends -y lftp
          echo "::endgroup::"

      - name: "Generate local checksums"
        shell: bash
        run: |
          echo "::group::Generating checksums for local files"
          cd app_publish
          
          # Use find's -print0 and xargs' -0 to handle all filenames and produce
          # checksums with a consistent space separator.
          find . -type f -print0 | xargs -0 md5sum > checksums.txt
          
          echo "::endgroup::"
      
      - name: "Download remote checksums"
        shell: bash
        env:
          SFTP_USERNAME: ${{ secrets.SFTP_USERNAME }}
          SFTP_PASSWORD: ${{ secrets.SFTP_PASSWORD }}
          SFTP_HOST: ${{ secrets.SFTP_HOST }}
        run: |
          echo "::group::Attempting to download remote checksum file"
          lftp -c "open sftp://${SFTP_USERNAME}:${SFTP_PASSWORD}@${SFTP_HOST}; \
            set sftp:auto-confirm yes; \
            get -O . /htdocs/checksums.txt || rm ./checksums.txt; \
            bye"
          
          mv checksums.txt remote_checksums.txt || touch remote_checksums.txt
          echo "::endgroup::"

      - name: "Compare checksums"
        shell: bash
        id: generate_checksums
        env:
          SFTP_USERNAME: ${{ secrets.SFTP_USERNAME }}
          SFTP_PASSWORD: ${{ secrets.SFTP_PASSWORD }}
          SFTP_HOST: ${{ secrets.SFTP_HOST }}
        run: |
          echo "::group::Comparing checksums"
          
          # Standardize both files to a tab-separated format
          # This replaces one or more spaces at the beginning of the filename
          # with a single tab, ensuring a clean format for join.
          sed -i -E 's/^([0-9a-f]{32})[[:space:]]+/\1\t/' "app_publish/checksums.txt"
          sed -i -E 's/^([0-9a-f]{32})[[:space:]]+/\1\t/' remote_checksums.txt

          # Remove the './' prefix from filenames in both checksum files
          sed -i -E 's/\t\.\//\t/' "app_publish/checksums.txt"
          sed -i -E 's/\t\.\//\t/' remote_checksums.txt

          # Remove any trailing whitespace and/or carriage returns to ensure consistent sorting.
          sed -i -E 's/[\r[:space:]]+$//' "app_publish/checksums.txt"
          sed -i -E 's/[\r[:space:]]+$//' remote_checksums.txt

          sed -i -E 's/[[:space:]]\t/\t/g; s/[ \t]*$//' "app_publish/checksums.txt"
          sed -i -E 's/[[:space:]]\t/\t/g; s/[ \t]*$//' remote_checksums.txt

          LC_ALL=C sort -t$'\t' -k 2,2 "app_publish/checksums.txt" > local_sorted.txt
          LC_ALL=C sort -t$'\t' -k 2,2 remote_checksums.txt > remote_sorted.txt
          
          echo "# lftp commands generated for deployment\n" > lftp_commands.txt
          echo "set sftp:auto-confirm yes\n" >> lftp_commands.txt

          # Conditional open command for security
          if [ "${{ github.event.inputs.dry-run }}" == "true" ]; then
            printf 'open "sftp://[USER]@[HOST]:22";\n' >> lftp_commands.txt
          else
            printf 'open "sftp://%s:%s@%s:22";\n' \
              "${SFTP_USERNAME}" \
              "${SFTP_PASSWORD}" \
              "${SFTP_HOST}" >> lftp_commands.txt
          fi

          echo "::endgroup::"

      - name: "lftp_commands.txt: Upload checksum files"
        if: ${{ github.event.inputs.dry-run == 'true' }}
        uses: actions/upload-artifact@v4
        with:
          name: sorted-checksum-files
          path: |
            local_sorted.txt
            remote_sorted.txt
          retention-days: 1
      
      - name: "Generate files to update"
        shell: bash
        id: generate_commands_update
        run: |
          echo "::group::Files to update"

          awk -F'\t' '
          BEGIN {
              FS="\t";
              deploy_file = "all_files_to_deploy.txt";
              remove_file = "files_to_remove.txt";
          }
          FNR==NR {
              local_files[$2] = $1;
              next;
          }
          {
              remote_file = $2;
              remote_checksum = $1;

              if (remote_file in local_files) {
                  local_checksum = local_files[remote_file];
                  if (local_checksum != remote_checksum) {
                      print remote_file > deploy_file;
                  }
                  delete local_files[remote_file];
              } else {
                  print remote_file > remove_file;
              }
          }
          END {
              for (new_file in local_files) {
                  print new_file > deploy_file;
              }
          }
          ' local_sorted.txt remote_sorted.txt

          echo "::endgroup::"


      - name: "Generate create ftp commands"
        shell: bash
        id: generate_commands_ftp
        run: |
          echo "::group::Create ftp commands"
          declare -A created_dirs
          while IFS= read -r file; do
            remote_file="/htdocs/$file"
            remote_dir="$(dirname "$remote_file")"
            
            if [[ -z "${created_dirs["$remote_dir"]}" ]]; then
              printf 'mkdir -p "%s";\n' "$remote_dir" >> lftp_commands.txt
              created_dirs["$remote_dir"]=1
            fi
            
            local_file="app_publish/$file"
            printf 'put "%s" -o "%s";\n' "$local_file" "$remote_file" >> lftp_commands.txt
          done < all_files_to_deploy.txt
          echo "::endgroup::"

      - name: "Generate rm commands"
        shell: bash
        id: generate_commands_rm
        run: |
          echo "::group::Create rm commands"

          if [ -s files_to_remove.txt ]; then

            while IFS=$'\n' read -r file; do
              case "$file" in
                "app_offline.htm")
                  printf "Skipping removal of maintenance page: %s\n" "$file" >> lftp_commands.txt
                  ;;
                wwwroot/umbraco/Data/*)
                  printf "Skipping removal of Umbraco Data file: %s\n" "$file" >> lftp_commands.txt
                  ;;
                wwwroot/umbraco/Logs/*)
                  printf "Skipping removal of Umbraco Logs file: %s\n" "$file" >> lftp_commands.txt
                  ;;
                wwwroot/media/*)
                  printf "Skipping removal of Umbraco Media file: %s\n" "$file" >> lftp_commands.txt
                  ;;
                *)
                  printf 'rm "%s/%s";\n' "/htdocs" "$file" >> lftp_commands.txt
                  ;;
              esac
            done < files_to_remove.txt

          else
            echo "No files to remove."
          fi
          echo "::endgroup::"

      - name: "End commands file"
        shell: bash
        run: |
          echo "::group::End commands file"

          echo "bye" >> lftp_commands.txt
          echo "::endgroup::"
      
      - name: "Put site in maintenance mode"
        if: ${{ github.event.inputs.dry-run != 'true' }}
        shell: bash
        env:
          SFTP_USERNAME: ${{ secrets.SFTP_USERNAME }}
          SFTP_PASSWORD: ${{ secrets.SFTP_PASSWORD }}
          SFTP_HOST: ${{ secrets.SFTP_HOST }}
        run: |
          echo "::group::Creating maintenance page app_offline.htm to take site offline"
          lftp -u "${SFTP_USERNAME},${SFTP_PASSWORD}" sftp://${SFTP_HOST}:22 -e "set sftp:auto-confirm yes; put 'app_offline.htm' -o '/htdocs/app_offline.htm'"
          echo "::endgroup::"
          
      - name: "Execute lftp commands with retries"
        if: ${{ github.event.inputs.dry-run != 'true' }}
        shell: bash
        run: |
          echo "::group::Executing deployment commands with retries"
          MAX_RETRIES=5
          RETRY_DELAY=10
          ATTEMPT=1
          
          while [ $ATTEMPT -le $MAX_RETRIES ]; do
            echo "Attempt $ATTEMPT of $MAX_RETRIES"
            
            # Capture the output of the lftp command
            OUTPUT=$(lftp -f lftp_commands.txt 2>&1)
            
            # Check if the output contains the specific error message.
            # The || true at the end prevents grep from failing the script
            # if the string is not found, allowing the 'if' condition to handle the logic.
            if echo "$OUTPUT" | grep -q "Access failed: I/O error." || echo "$OUTPUT" | grep -q "Transfer failed"; then
              echo "Deployment failed due to I/O error or failed transfer. Retrying in $RETRY_DELAY seconds..."
              echo "$OUTPUT" # Print the output for debugging
              sleep $RETRY_DELAY
              ATTEMPT=$((ATTEMPT+1))
            else
              echo "Deployment successful."
              echo "$OUTPUT" # Print the output for successful run
              exit 0
            fi
          done
          
          echo "Deployment failed after $MAX_RETRIES attempts."
          exit 1
          echo "::endgroup::"      
      - name: "Dry Run: Upload LFTP command files"
        if: ${{ github.event.inputs.dry-run == 'true' }}
        uses: actions/upload-artifact@v4
        with:
          name: lftp_commands-files
          path: |
            lftp_commands.txt
          retention-days: 1

      - name: "Upload new checksums file"
        if: ${{ github.event.inputs.dry-run != 'true' }}
        shell: bash
        env:
          SFTP_USERNAME: ${{ secrets.SFTP_USERNAME }}
          SFTP_PASSWORD: ${{ secrets.SFTP_PASSWORD }}
          SFTP_HOST: ${{ secrets.SFTP_HOST }}
        run: |
          echo "::group::Uploading new checksums file"
          lftp -u "${SFTP_USERNAME},${SFTP_PASSWORD}" sftp://${SFTP_HOST}:22 -e "set sftp:auto-confirm yes; put 'app_publish/checksums.txt' -o '/htdocs/checksums.txt'"
          echo "::endgroup::"

      - name: "Take site out of maintenance mode"
        if: ${{ github.event.inputs.dry-run != 'true' }}
        shell: bash
        env:
          SFTP_USERNAME: ${{ secrets.SFTP_USERNAME }}
          SFTP_PASSWORD: ${{ secrets.SFTP_PASSWORD }}
          SFTP_HOST: ${{ secrets.SFTP_HOST }}
        run: |
          echo "::group::Removing app_offline.htm to bring site online"

          mkdir -p ./temp/usync/v9
          touch ./temp/usync/v9/usync.once
          lftp -u "${SFTP_USERNAME},${SFTP_PASSWORD}" sftp://${SFTP_HOST}:22 -e "set sftp:auto-confirm yes; put './temp/usync/v9/usync.once' -o '/htdocs/uSync/v9/usync.once'; rm '/htdocs/app_offline.htm'"
          echo "::endgroup::"
      
  e2e_tests:
    runs-on: ubuntu-latest
    needs: deploy # This ensures this job runs only after the 'deploy' job completes successfully
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: lts/*
      - name: Install Playwright dependencies
        run: npm ci
      - name: Install Playwright Browsers
        run: npx playwright install --with-deps
      - name: Run Playwright tests against deployed URL
        env:
          PLAYWRIGHT_BASE_URL: https://theexchange-tod.com/ # Set the base URL for the tests
        run: npx playwright test
      - uses: actions/upload-artifact@v4
        if: ${{ !cancelled() }}
        with:
          name: playwright-report
          path: playwright-report/
          retention-days: 30