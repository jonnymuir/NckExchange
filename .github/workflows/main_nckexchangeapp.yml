# Docs for the GitHub Actions SFTP Deploy action: https://github.com/marketplace/actions/ftp-sftp-file-deployer

name: Build and Deploy Umbraco App to Fasthosts

on:
  push:
    branches:
      - main
    # The 'paths' keyword now ensures this workflow only runs when files
    # under the 'src' folder are modified.
    paths:
      - 'src/**'
  # The new 'workflow_dispatch' event allows you to run this workflow manually
  # and provide custom inputs.
  workflow_dispatch:
    inputs:
      dry-run:
        description: "Perform a dry run without actually deploying files."
        type: boolean
        required: true
        default: false      

jobs:
  build:
    runs-on: windows-latest
    permissions:
      contents: read

    steps:
      - uses: actions/checkout@v4

      - name: Set up .NET Core
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '8.x'

      - name: Build with dotnet
        run: dotnet build --configuration Release

      - name: dotnet publish
        run: dotnet publish -c Release -o "publish" --no-self-contained

      - name: Upload artifact for deployment job
        uses: actions/upload-artifact@v4
        with:
          name: .net-app
          path: publish

  deploy:
    runs-on: ubuntu-latest
    needs: build
    permissions:
      id-token: write
      contents: read

    steps:
      - uses: actions/checkout@v4

      - name: Download artifact from build job
        uses: actions/download-artifact@v4
        with:
          name: .net-app
          path: ./app_publish
      
      - name: Create appsettings.json for Production
        env:
          UMBRACO_DB_DSN: ${{ secrets.UMBRACO_DB_DSN }}
        run: |
          # Use 'jq' to modify the JSON file.
          # The DSN is now passed via an environment variable.
          jq \
            --arg dsn "$UMBRACO_DB_DSN" \
            '.ConnectionStrings = {
                "umbracoDbDSN": $dsn,
                "umbracoDbDSN_ProviderName": "Microsoft.Data.SqlClient"
             } |
             .uSync.Settings.ImportAtStartup = true' \
            app_publish/appsettings.json > app_publish/appsettings.json.tmp && \
            mv app_publish/appsettings.json.tmp app_publish/appsettings.json
    
      # Upload to Fasthosts
      - name: "Install dependencies"
        shell: bash
        run: |
          echo "::group::Install packages"
          DEBIAN_FRONTEND=noninteractive sudo apt-get update && sudo apt-get install --no-install-recommends -y lftp
          echo "::endgroup::"

      - name: "Generate local checksums"
        shell: bash
        run: |
          echo "::group::Generating checksums for local files"
          cd app_publish
          
          # Use find's -print0 and xargs' -0 to handle all filenames and produce
          # checksums with a consistent space separator.
          find . -type f -print0 | xargs -0 md5sum > checksums.txt
          
          echo "::endgroup::"
      
      - name: "Download remote checksums"
        shell: bash
        env:
          SFTP_USERNAME: ${{ secrets.SFTP_USERNAME }}
          SFTP_PASSWORD: ${{ secrets.SFTP_PASSWORD }}
          SFTP_HOST: ${{ secrets.SFTP_HOST }}
        run: |
          echo "::group::Attempting to download remote checksum file"
          lftp -u "${SFTP_USERNAME},${SFTP_PASSWORD}" sftp://${SFTP_HOST}:22 -c "set sftp:auto-confirm yes; \
                    get -O . \"app_publish/checksums.txt\" || rm \"./checksums.txt\"" &>/dev/null || true
          mv checksums.txt remote_checksums.txt || touch remote_checksums.txt
          echo "::endgroup::"

      - name: "Compare checksums"
        shell: bash
        id: generate_checksums
        env:
          SFTP_USERNAME: ${{ secrets.SFTP_USERNAME }}
          SFTP_PASSWORD: ${{ secrets.SFTP_PASSWORD }}
          SFTP_HOST: ${{ secrets.SFTP_HOST }}
        run: |
          echo "::group::Comparing checksums"
          
          # Standardize both files to a tab-separated format
          # This replaces one or more spaces at the beginning of the filename
          # with a single tab, ensuring a clean format for join.
          sed -i -E 's/^([0-9a-f]{32})[[:space:]]+/\1\t/' "app_publish/checksums.txt"
          sed -i -E 's/^([0-9a-f]{32})[[:space:]]+/\1\t/' remote_checksums.txt

          # Remove the './' prefix from filenames in both checksum files
          sed -i -E 's/\t\.\//\t/' "app_publish/checksums.txt"
          sed -i -E 's/\t\.\//\t/' remote_checksums.txt

          # Remove any trailing whitespace and/or carriage returns to ensure consistent sorting.
          sed -i -E 's/[\r[:space:]]+$//' "app_publish/checksums.txt"
          sed -i -E 's/[\r[:space:]]+$//' remote_checksums.txt

          sed -i -E 's/[[:space:]]\t/\t/g; s/[ \t]*$//' "app_publish/checksums.txt"
          sed -i -E 's/[[:space:]]\t/\t/g; s/[ \t]*$//' remote_checksums.txt

          LC_ALL=C sort -t$'\t' -k 2,2 "app_publish/checksums.txt" > local_sorted.txt
          LC_ALL=C sort -t$'\t' -k 2,2 remote_checksums.txt > remote_sorted.txt
          
          echo "# lftp commands generated for deployment" > lftp_commands.txt

          # Conditional open command for security
          if [ "${{ github.event.inputs.dry-run }}" == "true" ]; then
            printf 'open "sftp://[USER]@[HOST]:22";\n' >> lftp_commands.txt
          else
            printf 'open "sftp://%s:%s@%s:22";\n' \
              "${SFTP_USERNAME}" \
              "${SFTP_PASSWORD}" \
              "${SFTP_HOST}" >> lftp_commands.txt
          fi

          echo "::endgroup::"

      - name: "lftp_commands.txt: Upload checksum files"
        if: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.dry-run == true || false }}
        uses: actions/upload-artifact@v4
        with:
          name: sorted-checksum-files
          path: |
            local_sorted.txt
            remote_sorted.txt
          retention-days: 1
      
      - name: "Generate files to update"
        shell: bash
        id: generate_commands_update
        run: |
          echo "::group::Files to update"

          awk -F'\t' '
          BEGIN {
              FS="\t";
              deploy_file = "all_files_to_deploy.txt";
              remove_file = "files_to_remove.txt";
          }
          FNR==NR {
              local_files[$2] = $1;
              next;
          }
          {
              remote_file = $2;
              remote_checksum = $1;

              if (remote_file in local_files) {
                  local_checksum = local_files[remote_file];
                  if (local_checksum != remote_checksum) {
                      print remote_file > deploy_file;
                  }
                  delete local_files[remote_file];
              } else {
                  print remote_file > remove_file;
              }
          }
          END {
              for (new_file in local_files) {
                  print new_file > deploy_file;
              }
          }
          ' local_sorted.txt remote_sorted.txt

          echo "::endgroup::"


      - name: "Generate create ftp commands"
        shell: bash
        id: generate_commands_ftp
        run: |
          echo "::group::Create ftp commands"
          declare -A created_dirs
          while IFS= read -r file; do
            remote_file="htdocs/$file"
            remote_dir="$(dirname "$remote_file")"
            
            if [[ -z "${created_dirs["$remote_dir"]}" ]]; then
              printf 'mkdir -p "%s";\n' "$remote_dir" >> lftp_commands.txt
              created_dirs["$remote_dir"]=1
            fi
            
            local_file="app_publish/$file"
            printf 'put "%s" -o "%s";\n' "$local_file" "$remote_file" >> lftp_commands.txt
          done < all_files_to_deploy.txt
          echo "::endgroup::"

      - name: "Generate rm commands"
        shell: bash
        id: generate_commands_rm
        run: |
          echo "::group::Create rm commands"

          if [ -s files_to_remove.txt ]; then

            while IFS=$'\n' read -r file; do
              case "$file" in
                "app_offline.htm")
                  printf "Skipping removal of maintenance page: %s\n" "$file" >> lftp_commands.txt
                  ;;
                wwwroot/umbraco/Data/*)
                  printf "Skipping removal of Umbraco Data file: %s\n" "$file" >> lftp_commands.txt
                  ;;
                wwwroot/umbraco/Logs/*)
                  printf "Skipping removal of Umbraco Logs file: %s\n" "$file" >> lftp_commands.txt
                  ;;
                wwwroot/media/*)
                  printf "Skipping removal of Umbraco Media file: %s\n" "$file" >> lftp_commands.txt
                  ;;
                *)
                  printf 'rm "%s/%s";\n' "htdocs" "$file" >> lftp_commands.txt
                  ;;
              esac
            done < files_to_remove.txt

          else
            echo "No files to remove."
          fi
          echo "::endgroup::"

      - name: "End commands file"
        shell: bash
        run: |
          echo "::group::End commands file"

          echo "bye" >> lftp_commands.txt
          echo "::endgroup::"
      
      - name: "Put site in maintenance mode"
        if: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.dry-run == false || github.event_name != 'workflow_dispatch' }}
        shell: bash
        env:
          SFTP_USERNAME: ${{ secrets.SFTP_USERNAME }}
          SFTP_PASSWORD: ${{ secrets.SFTP_PASSWORD }}
          SFTP_HOST: ${{ secrets.SFTP_HOST }}
        run: |
          echo "::group::Creating maintenance page app_offline.htm to take site offline"
          lftp -u "${SFTP_USERNAME},${SFTP_PASSWORD}" sftp://${SFTP_HOST}:22 -c "set sftp:auto-confirm yes; \
                    put \"app_offline.htm\" -o \"htdocs/app_offline.htm\""
          echo "::endgroup::"
          
      - name: "Execute lftp commands"
        if: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.dry-run == false || github.event_name != 'workflow_dispatch' }}
        shell: bash
        run: |
          echo "::group::Executing deployment commands"
          lftp -f lftp_commands.txt
          echo "::endgroup::"

      - name: "Dry Run: Upload LFTP command files"
        if: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.dry-run == true || false }}
        uses: actions/upload-artifact@v4
        with:
          name: lftp_commands-files
          path: |
            lftp_commands.txt
          retention-days: 1

      - name: "Upload new checksums file"
        if: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.dry-run == false || github.event_name != 'workflow_dispatch' }}
        shell: bash
        env:
          SFTP_USERNAME: ${{ secrets.SFTP_USERNAME }}
          SFTP_PASSWORD: ${{ secrets.SFTP_PASSWORD }}
          SFTP_HOST: ${{ secrets.SFTP_HOST }}
        run: |
          echo "::group::Uploading new checksums file"
          lftp -u "${SFTP_USERNAME},${SFTP_PASSWORD}" sftp://${SFTP_HOST}:22 -c "set sftp:auto-confirm yes; \
                    put \"app_publish/checksums.txt\" -o \"htdocs/checksums.txt\""
          echo "::endgroup::"

      - name: "Take site out of maintenance mode"
        if: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.dry-run == false || github.event_name != 'workflow_dispatch' }}
        shell: bash
        env:
          SFTP_USERNAME: ${{ secrets.SFTP_USERNAME }}
          SFTP_PASSWORD: ${{ secrets.SFTP_PASSWORD }}
          SFTP_HOST: ${{ secrets.SFTP_HOST }}
        run: |
          echo "::group::Removing app_offline.htm to bring site online"

          mkdir -p ./temp/usync/v9
          touch ./temp/usync/v9/usync.once

          lftp -u "${SFTP_USERNAME},${SFTP_PASSWORD}" sftp://${SFTP_HOST}:22 -c "set sftp:auto-confirm yes; \
                    put \"./temp/usync/v9/usync.once\" -o \"htdocs/uSync/v9/usync.once\"; \
                    rm \"htdocs/app_offline.htm\""
          echo "::endgroup::"
      
  e2e_tests:
    runs-on: ubuntu-latest
    needs: deploy # This ensures this job runs only after the 'deploy' job completes successfully
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: lts/*
      - name: Install Playwright dependencies
        run: npm ci
      - name: Install Playwright Browsers
        run: npx playwright install --with-deps
      - name: Run Playwright tests against deployed URL
        env:
          PLAYWRIGHT_BASE_URL: https://theexchange-tod.com/ # Set the base URL for the tests
        run: npx playwright test
      - uses: actions/upload-artifact@v4
        if: ${{ !cancelled() }}
        with:
          name: playwright-report
          path: playwright-report/
          retention-days: 30